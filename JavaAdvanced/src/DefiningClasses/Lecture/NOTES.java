package DefiningClasses.Lecture;

public class NOTES {

    double money;
    double sum;

    /* Access Modifiers:
    Винаги когато имаме обвързани полета на един клас (amount, hasМoney) с някаква логика (примерно сумата ако стане = 0,
    булината hasMoney става равна на false -> не трябва да се позволява на външния свят да контролира тази логика.
    Затова полетата са private и не могат да се променят отвън с външни методи. Логиката за тяхната промяна е в методите на самия клас.
     */

    public void getMoney(int money){}
//    сигнатура на метода = името на метида и типа на параметър - getMoney(int)
//    access modifier, return type and name of parameter - не са сигнатури

    // и полетата и методите са class members на класовете

    // за да override-ваме метод , то той тр да има абсолютно същата сигнатура (име + тип на параметър) и същия return type,
    // но само добавяме друго тяло на метода!!!
    // ако променя параметъра, това вече е друг метод, а не овъррайдване! toString() != toString(String) - различна сигнатура
    //ако сложа @Override анотация и съм объркала нещо по сигнатурата на метода, то тя ще ми светне като компилац грещка
    //ако не съм объркала нищо по сигнатурата, овърайд анотацията ще се съгласи
    // ако сменя return typa-a овърайд анотацията не показва грешка, но ретърн типа показва грещка, защото не е овърайд
    //имам право да сменям само тялото на метода

    // когато пишем метод, и не му подаваме променлива, тогава няма нужда да пишем this. пред клас мембъра,
    // на който присвояваме променливата!

    public void setMoney(int money){
        money = money; //-> това под money параметъра и все едно присвояваме параметъра на параметъра, затова се пише this.money = money
        // за да реферираме към клас мембъра
    }

//    ако обаче имама примерно метод, в който параметъра не е същия като клас мембъра:
    public void setTheMoney(){
        money = sum; //- не е нужно да се пише this.
    }

    // и при гетъри и при сетъри може да има параметри, които да са примерно някакви усовия в имплементацията

    //CONSTRUCTORS
    //Констр може да бъде извикан само след ключовата дума new
    //конструира инстанция на обект - създава обект, като гарантира, че той ще е създаден по правилния начин
    //нямат ретърн тип, защото техния ретърн тип е името на класа
    //дефолтен конструктор - ако не напишем никакъв конструктор получаваме дефолтния конструктор:
//    public Car() {
//    }
    // дефолтният е създаден от компилатора, за да можем някак си да създаваме обекти от този клас
    //ако напишем какъвто и да е друг конструктор, получаваме него при викане,
    // и дефолтния, който е без параметри, вече не може да бъде извикан - т.е. той не се създава автоматично
    //ако искаме да го имаме, трябва да го напишем ръчно
    // Констр е договор между нас и компилатора, че ще създадем обекта по правилния начин
    //никой не може да създаде обект по друг начин, освен по начина, който сме дефинирали в конструктора
    // К е нещо като договор, че ще получим обекта точно такъв ,какъвто трябва да бъде
    // ако правим обекта чрез сетърите, можем да забравим нещо,
    // а чрез конструктора, се иска да му се подадат точно всички изисквания като параметри
    // Конструктора се вика само веднъж при създаване на първоначалното състояние на обекта
    // и не може да се вика повече от веднъж за един обект
    //ако искаме да променяме после състоянието - гетъри и сетъри

    //ако искаме да валидираме примерно възраст да не е < 0, можем да го направим в сетъра
    //за да не преповтаряме кода за валидиране и в конструктора,
   // можем да викнем сетъра в конструктора, за да валидираме входните данни

//    public  Cat () {
//        this.setAge(0);
//    }
//
//    public int setAge(int age){
//        if (age < 0){
//            throw new IllegalArgumentException("Age cannot be negative");
//        }
//        this.age = age;
//    }

    // мога да създавам повече от един К, като единственото, което променям е в сигнатурата - различен брой и тип параметри

    // public Car(String model) {
    //    }
    //public Car(String brand) {
    //    }

    // тези два конструктора ще ни дадат компилационна грешка, защото сигнатурата им е еднаква Car(String) и те не са различни

    //ако имам обекти (примерно List) като полета на класа, е добре да се инициализират в конструктора
    // дори и като празни !! List<Integer> = new ArrayList<>; - празен лист

    // Constructor chaining:
    // код не трябва да се преповтаря, дори и в конструкторите, защото при се забравя да се упдейтне при промяна
    // затова се ползва ком=нструктор чейнинг

    //пример - повтаряне на код

//    public Car(String brand, String model, int horsePower){
//        this.brand = brand;
//        this.model = model;
//        this horsePower = horsePower;
//    }
//
//    public Car(String brand, String model){
//        this.brand = brand;
//        this.model = model;
//    }

    // пример конструктор чейнинг за избягване на повторението:
//    public Car(String brand, String model, int horsePower){
//        this.brand = brand;
//        this.model = model;
//        this horsePower = horsePower;
//    }
//
//    public Car(String brand, String model){
//        this(brand, model, horsePower = 0); // - вика горния конструктор, и му слага дефолта на хорспауър полето
//    }

    //правило: винаги правим конструктор чейнинг в конструктора с по-малкото параметри викаме конструктора с повечето параметри!!!!

//STATIC CLASSES
    //Не винаги искам всичко, което се намира в моя клас да бъде обвързано с инстанциране на обект от тоя тип
    // сатичните променливи са обвързани със класа, със шаблона, а не със инстанциите.
    // Не е нужно да създаваме нови обекти, за да викаме тези методи.
//    Integer.parseInt("5";)
//    Math.max(1, 2);

    // private static int sum; - статичните полета са такива които принадлежат на класа - те ще са за всички негови инстанции!!!
    // те са общи за всички инстанции на класа
    //ако в един обект променяме статично поле, то това ще се отрази на всички инстанции на класа (на всички негови обекти)
//ако променяме инстанционно поле, то това ще се отрази само на този обект
//    public static String favoriteFood;
//    tom. favoriteFood = "torta";
//    pesho.favoriteFood = "banichka";
// тук tom и pesho са различни обекти, но те са от един и същ клас,
// затова favoriteFood първо ще бъде торта и за двамата,
// а после ще бъде "banichka" и за двамата
    //защото favoriteFood е статично поле и е общо за всички инстанции на класа
    //обикновенно правим статични променливи, когато искаме да имаме една обща променлива за всички инстанции на класа
    //примерно някакъв каунтър, който ще брои номерата на всички създадени обекти от този клас

    //статични методи се правят за нещо, което всички обекти могат да правят, независимо от това дали са създадени



}
